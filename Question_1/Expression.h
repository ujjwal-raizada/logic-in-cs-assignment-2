#include<iostream>
#include<vector>
#include<iostream>
#include<string>
#include<stack>
#include<chrono> // header for time calculation

using namespace std;
using namespace std::chrono;

bool isOperator(char c) {
	if(c == '^' || c == 'V' || c == '~' || c == '>') {
		return true;
	}
	return false;
}

bool isNegation(char c) {
	if(c == '~')
		return true;
	return false;
}

struct node {
		char value;
		node *left, *right;
};

/*! Expression class holds  postfix expression, and provides
   methods for taking input, creating parse tree and printing 
   in-order transversal */
class Expression {


  protected:
	string postfix_exp, infix_exp; 
	node *parse_tree; /*!< It is a pointer to root of the parse_tree */

	

	node *newNode(char value) {
		node *temp = new node;
		temp -> left = temp -> right = NULL;
		temp -> value = value;
		return temp;
	}

	
	/* Actual recursive function to print inorder */
	void inOrder(node *root) {

		//Recursive inOrder Transversal

		if(root != NULL) {
			if(root -> right != NULL) 
				infix_output += "(";

			inOrder(root -> left);
			infix_output += root -> value;
			inOrder(root -> right);

			if(root -> right != NULL)
				infix_output += ")";
		}
	}

  public:
	string infix_output; /*!< Infix notation generated by inOrder Transversal */

	/*! This method is used to create a parse tree from the given postfix */
	void createParseTree();


	void postFix();

	/*! This setter method is used for setting the value for postfix string  */
	void setPostfix(string exp) {
		postfix_exp = exp;
	}

	/*! This setter method is used for setting the value for infix string */
	void setInfix(string exp) {
		infix_exp = exp;
	}

	
	/*! This method is used to print the inorder of the parse tree. */
	void printInOrder() {
		cout << "Infix expression from parse tree: ";
		infix_output = "";
		inOrder(parse_tree);
		cout<<infix_output;
	}

	/*! This Method verify if the inputted infix is well formed or not */
	void verifyWellFormed() {
		if (infix_exp == infix_output)
			cout << "\nGiven Formula is Well Formed\n";
		else
			cout << "\nGiven Formula is not Well Formed\n";
	}
};

void Expression::createParseTree() {

	stack<node*> Stack;
	node *root, *left, *right;

	for(int i = 0; i < postfix_exp.size(); i++) {
		if(!isOperator(postfix_exp[i])) {
			root = newNode(postfix_exp[i]);
			Stack.push(root);
		}
		else { // given char is Operator

			if(isNegation(postfix_exp[i])) { // Negation Operator <Unary Operator>
				root = newNode(postfix_exp[i]);
				right = Stack.top(); // Return Element from Top
				Stack.pop(); //Remove Element from Top

				root -> right = right; // make left children
				Stack.push(root);
			}
			else { // Operator other than negation <Binary Operator>
				root = newNode(postfix_exp[i]);

				right = Stack.top();
				Stack.pop();
				left = Stack.top();
				Stack.pop();

				// making left and right children of root
				root -> left = left;
				root -> right = right;

				// Add this sub-Tree to stack
				Stack.push(root);
			}
		}
	}

	root = Stack.top();
	Stack.pop();

	// Assigning root of complete tree to parse_tree Data Member 
	parse_tree = root;
}

/*! This method convert infix notation to postfix notation. */
void Expression::postFix(){

	string s = infix_exp, output;
	vector <char> Stack(1,'#');
	int len = s.length(), flag = 0;

	for(int i = 0; i < len; i++) {
		char ch = s[i];
		if (s[i] == '(')
			Stack.push_back(ch);
		else if (s[i] == 'V' or s[i] == '^' or s[i] == '>')
			Stack.push_back(ch);
		else if (ch == ')') {
			while(Stack.back() != '(' and Stack.back() != '#') {
				output += Stack.back();
				Stack.pop_back();
			}

			if (Stack.back() == '(') {
				Stack.pop_back();
				if(Stack.back() == '~'){
					output += '~';
					Stack.pop_back();
				}
			}
		}
		else if (ch == '~') {
			if(s[i+1] != '(') {
				output += s[i+1];
				output += '~';
				i += 1; 
			}
			else{
				Stack.push_back('~');
			}
		}
		else
			output += ch;		
	}

	setPostfix(output);
	cout << "Postfix is :";
	cout<<output;
	cout << endl;
}

